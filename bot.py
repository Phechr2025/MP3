import logging, asyncio, os, subprocess, urllib.request, tempfile
from typing import Union
from telegram import Update, CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    Application, CommandHandler, MessageHandler,
    ConversationHandler, CallbackQueryHandler,
    ContextTypes, filters
)
import yt_dlp
from dotenv import load_dotenv

# ‡πÇ‡∏´‡∏•‡∏î‡∏Ñ‡πà‡∏≤ TOKEN ‡πÅ‡∏•‡∏∞ ADMIN_ID ‡∏à‡∏≤‡∏Å .env
load_dotenv()
TOKEN = os.getenv("BOT_TOKEN", "PUT_YOUR_BOT_TOKEN_HERE")
ADMIN_ID = os.getenv("ADMIN_ID", "")

DOWNLOAD_DIR = "downloads"
os.makedirs(DOWNLOAD_DIR, exist_ok=True)

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)
logger = logging.getLogger("ytmp3-bot")

ASK_LINK, ASK_FILENAME, ASK_SENDTO = range(3)
CURRENT_TASK = None
CURRENT_OWNER_ID = None
CURRENT_ORIGIN_CHAT_ID = None
HELP_COMMANDS = {}

def get_user_id(u: Union[Update, CallbackQuery]) -> int:
    if isinstance(u, CallbackQuery):
        return u.from_user.id
    return u.effective_user.id

def get_chat_id(u: Union[Update, CallbackQuery]) -> int | None:
    if isinstance(u, CallbackQuery):
        return u.message.chat.id if u.message else None
    return u.effective_chat.id

async def send_text(u: Union[Update, CallbackQuery], ctx: ContextTypes.DEFAULT_TYPE, text: str):
    try:
        if isinstance(u, CallbackQuery):
            if u.message:
                return await u.edit_message_text(text)
            return await ctx.bot.send_message(chat_id=u.from_user.id, text=text)
        else:
            return await u.message.reply_text(text)
    except Exception:
        if isinstance(u, CallbackQuery):
            return await ctx.bot.send_message(chat_id=u.from_user.id, text=text)

def is_single_video(url: str) -> bool:
    return not ("playlist" in url or "list=" in url)

# ---------------- ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏´‡∏•‡∏±‡∏Å ----------------
async def start(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    text = (
        "üéß YTMP3 Bot v6\n\n"
        "‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ:\n"
        "/ytmp3 - ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î YouTube ‡πÄ‡∏õ‡πá‡∏ô MP3\n"
        "/cancel - ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥\n"
        "/status - ‡∏î‡∏π‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö\n"
        "/help - ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î\n"
        "/clearlock - ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏•‡πá‡∏≠‡∏Å (‡πÉ‡∏ä‡πâ‡∏ñ‡πâ‡∏≤‡∏á‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤‡∏á)\n\n"
        "üí° ‡∏Ñ‡∏∏‡∏ì‡∏¢‡∏±‡∏á‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏ó‡∏µ‡πà‡πÅ‡∏≠‡∏î‡∏°‡∏¥‡∏ô‡∏ï‡∏±‡πâ‡∏á‡πÄ‡∏≠‡∏á‡πÑ‡∏î‡πâ ‡πÄ‡∏ä‡πà‡∏ô '‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠' ‡∏´‡∏£‡∏∑‡∏≠ '‡∏ï‡∏¥‡∏î‡∏ï‡πà‡∏≠‡πÅ‡∏≠‡∏î‡∏°‡∏¥‡∏ô'"
    )
    await update.message.reply_text(text)

async def help_cmd(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    cmds = [
        "/ytmp3 - ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î YouTube ‡πÄ‡∏õ‡πá‡∏ô MP3",
        "/cancel - ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥",
        "/status - ‡∏î‡∏π‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö",
        "/help - ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
        "/clearlock - ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏•‡πá‡∏≠‡∏Å (‡πÉ‡∏ä‡πâ‡∏ñ‡πâ‡∏≤‡∏á‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤‡∏á)"
    ]
    if HELP_COMMANDS:
        cmds.append("\n‚ú® ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏û‡∏¥‡πÄ‡∏®‡∏©:")
        for k, v in HELP_COMMANDS.items():
            cmds.append(f"- {k}: {v}")
    await update.message.reply_text("üìå ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î:\n" + "\n".join(cmds))

async def status(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if CURRENT_TASK:
        await update.message.reply_text("üöß ‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏¢‡∏π‡πà")
    else:
        await update.message.reply_text("‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏ß‡πà‡∏≤‡∏á ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô")

async def clearlock(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    global CURRENT_TASK, CURRENT_OWNER_ID, CURRENT_ORIGIN_CHAT_ID
    CURRENT_TASK = None
    CURRENT_OWNER_ID = None
    CURRENT_ORIGIN_CHAT_ID = None
    await update.message.reply_text("üßπ ‡πÄ‡∏Ñ‡∏•‡∏µ‡∏¢‡∏£‡πå‡∏•‡πá‡∏≠‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß")

# ---------------- Workflow ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î ----------------
async def ytmp3(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üìé ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡∏•‡∏¥‡∏á‡∏Å‡πå YouTube (‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢ http ‡∏´‡∏£‡∏∑‡∏≠ https)")
    return ASK_LINK

async def ask_filename(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    url = update.message.text.strip()
    if not (url.startswith("http://") or url.startswith("https://")):
        await update.message.reply_text("‚ùå ‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏ï‡πâ‡∏≠‡∏á‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡πâ‡∏ô‡∏î‡πâ‡∏ß‡∏¢ http:// ‡∏´‡∏£‡∏∑‡∏≠ https:// ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô")
        return ConversationHandler.END
    if not is_single_video(url):
        await update.message.reply_text("‚ùå ‡∏•‡∏¥‡∏á‡∏Å‡πå‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ß‡∏¥‡∏î‡∏µ‡πÇ‡∏≠‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡∏à‡∏≤‡∏Å YouTube ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡πÉ‡∏´‡∏°‡πà")
        return ConversationHandler.END
    ctx.user_data["url"] = url
    await update.message.reply_text("üìù ‡∏ï‡∏±‡πâ‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå (‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà .mp3)\n‡∏û‡∏¥‡∏°‡∏û‡πå No ‡∏ñ‡πâ‡∏≤‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡∏ä‡∏∑‡πà‡∏≠‡∏à‡∏≤‡∏Å YouTube\n‚ö†Ô∏è ‡∏ñ‡πâ‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ ‡∏≠‡∏≤‡∏à‡πÑ‡∏î‡πâ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö")
    return ASK_FILENAME

async def ask_sendto(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    filename = (update.message.text or "").strip() or "No"
    ctx.user_data["filename"] = filename

    keyboard = [[
        InlineKeyboardButton("üì• ‡∏™‡πà‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß", callback_data="dm"),
        InlineKeyboardButton("üë• ‡∏™‡πà‡∏á‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°", callback_data="group"),
    ]]
    await update.message.reply_text("üì§ ‡∏à‡∏∞‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏´‡∏ô‡∏Ñ‡∏£‡∏±‡∏ö?", reply_markup=InlineKeyboardMarkup(keyboard))
    return ASK_SENDTO

async def ask_sendto_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    choice = query.data
    await query.answer("‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î...", show_alert=False)
    if query.message:
        await query.edit_message_text(f"‚è≥ ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏•‡∏∑‡∏≠‡∏Å: {'‡∏™‡πà‡∏á‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß' if choice=='dm' else '‡∏™‡πà‡∏á‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°'}\n‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£...")
    return await start_download(update, ctx, sendto=choice)

def _progress_hook(d, status_msg, ctx):
    if d['status'] == 'downloading':
        percent = d.get('_percent_str', '').strip()
        asyncio.create_task(status_msg.edit_text(f"‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î... {percent}"))
    elif d['status'] == 'finished':
        asyncio.create_task(status_msg.edit_text("‚úÖ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå..."))

async def start_download(u: Union[Update, CallbackQuery], ctx: ContextTypes.DEFAULT_TYPE, sendto: str):
    global CURRENT_TASK, CURRENT_OWNER_ID, CURRENT_ORIGIN_CHAT_ID
    if CURRENT_TASK:
        await send_text(u, ctx, "‚õî ‡∏°‡∏µ‡∏á‡∏≤‡∏ô‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏≠‡∏¢‡∏π‡πà ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏£‡∏≠‡∏Å‡πà‡∏≠‡∏ô")
        return ConversationHandler.END

    uid = get_user_id(u)
    cid = get_chat_id(u)
    CURRENT_OWNER_ID, CURRENT_ORIGIN_CHAT_ID = uid, cid
    url = ctx.user_data["url"]
    filename = (ctx.user_data.get("filename") or "No").strip()
    status_msg = await send_text(u, ctx, "‚è≥ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î...")

    async def task():
        global CURRENT_TASK, CURRENT_OWNER_ID, CURRENT_ORIGIN_CHAT_ID
        try:
            ydl_opts = {
                "format": "bestaudio/best",
                "outtmpl": os.path.join(DOWNLOAD_DIR, "%(title)s.%(ext)s"),
                "noplaylist": True,
                "writethumbnail": True,
                "progress_hooks": [lambda d: _progress_hook(d, status_msg, ctx)],
                "postprocessors": [
                    {"key": "FFmpegExtractAudio", "preferredcodec": "mp3", "preferredquality": "192"},
                    {"key": "EmbedThumbnail"},
                    {"key": "FFmpegMetadata"},
                ],
                "quiet": True,
            }
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=True)
                out_file = ydl.prepare_filename(info)
                if out_file.endswith(".webm"):
                    out_file = out_file[:-5] + ".mp3"
                elif out_file.endswith(".m4a"):
                    out_file = out_file[:-4] + ".mp3"

            display_name = info.get("title", "Audio") if filename.lower() == "no" else filename
            caption = f"üéµ {display_name}\n‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô: {os.path.basename(out_file)}"

            if sendto == "group":
                if isinstance(u, CallbackQuery) and u.message and u.message.chat.type in ("group", "supergroup"):
                    target_chat = u.message.chat.id
                elif isinstance(u, Update) and u.effective_chat and u.effective_chat.type in ("group", "supergroup"):
                    target_chat = u.effective_chat.id
                else:
                    target_chat = CURRENT_OWNER_ID
                    caption += "\n‚ÑπÔ∏è ‡πÉ‡∏ä‡πâ '‡∏™‡πà‡∏á‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏°' ‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ñ‡πâ‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÉ‡∏ô‡∏Å‡∏•‡∏∏‡πà‡∏° ‚Üí ‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß‡πÅ‡∏ó‡∏ô"
            else:
                target_chat = CURRENT_OWNER_ID

            with open(out_file, "rb") as f:
                await ctx.bot.send_audio(
                    chat_id=target_chat,
                    audio=f,
                    title=display_name,
                    performer="YouTube",
                    caption=caption,
                    parse_mode=ParseMode.HTML,
                )

            if status_msg:
                await status_msg.edit_text("‚úÖ ‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô!")
        except Exception as e:
            logger.exception("Download error")
            if status_msg:
                await status_msg.edit_text(f"‚ùå ‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {e}")
        finally:
            CURRENT_TASK = None
            CURRENT_OWNER_ID = None
            CURRENT_ORIGIN_CHAT_ID = None

    CURRENT_TASK = asyncio.create_task(task())
    return ConversationHandler.END

# ---------------- Utility ----------------
async def cancel(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    global CURRENT_TASK, CURRENT_OWNER_ID
    if CURRENT_TASK and CURRENT_OWNER_ID == update.effective_user.id:
        CURRENT_TASK.cancel()
        CURRENT_TASK = None
        CURRENT_OWNER_ID = None
        await update.message.reply_text("üõë ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏á‡∏≤‡∏ô‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢")
    else:
        await update.message.reply_text("‚ÑπÔ∏è ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏á‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥")

# ---------------- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏û‡∏¥‡πÄ‡∏®‡∏© ----------------
async def set_custom_command(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if str(update.effective_user.id) != str(ADMIN_ID):
        await update.message.reply_text("‚ùå ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏≠‡∏î‡∏°‡∏¥‡∏ô ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏ä‡πâ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ")
        return
    if len(ctx.args) < 2:
        await update.message.reply_text("‚ö†Ô∏è ‡πÉ‡∏ä‡πâ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: /setcmd [‡∏Ñ‡∏≥] [‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°/‡∏•‡∏¥‡∏á‡∏Å‡πå]")
        return
    key = ctx.args[0]
    val = " ".join(ctx.args[1:])
    HELP_COMMANDS[key] = val
    await update.message.reply_text(f"‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏û‡∏¥‡πÄ‡∏®‡∏© '{key}' ‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢")

async def custom_command_handler(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    text = update.message.text.strip()
    if text in HELP_COMMANDS:
        await update.message.reply_text(HELP_COMMANDS[text])

def main():
    app = Application.builder().token(TOKEN).build()
    conv = ConversationHandler(
        entry_points=[CommandHandler("ytmp3", ytmp3)],
        states={
            ASK_LINK: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_filename)],
            ASK_FILENAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_sendto)],
            ASK_SENDTO: [CallbackQueryHandler(ask_sendto_callback)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(CommandHandler("status", status))
    app.add_handler(CommandHandler("clearlock", clearlock))
    app.add_handler(CommandHandler("cancel", cancel))
    app.add_handler(CommandHandler("setcmd", set_custom_command))
    app.add_handler(conv)
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, custom_command_handler))
    app.run_polling()

if __name__ == "__main__":
    main()
